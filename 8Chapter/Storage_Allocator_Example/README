example of to free memmory in program:

malloc() will request space from the operating system as needed. Since other activities in the program may also request space without calling this allocator, the space that malloc manages may not be contiguous. Storage is kept  as a list of free blocks. Each block contains a size, a pointer to the next block and the space itself. The blocks are kept in order of increasing storage address, and the last block (highest address) points to the first. When a request is made, the list is scanned until a big-enough block is found. This algorithm is called "first fit" by contrast with "best fit," which looks for the smallest block that will satsfy the request. If the block is exactly the size requested it is unlinked from the list and returned to the user. If the block is too big, it is split, and the proper amount is returned to the user while the residue remains on the free list. If no big-enough block is found, another large chunk is obtained by the operating system and linked into the free list.

Freeing also causes a search of the free list, to find the proper place to insert the block on either side, it is coalesced with it into a single bigger block, so storage does not become too fragmented. Determining the adjacency is easy because the free list is maintained in order of decreasing address. 

A free block contains a pointer to the next block in the chain, a record of the size of the block, and then the free space itself; the control information at the beginning is called the "header." To simplify alignment, all blocks are multiples of the header size, and the header is aligned properly. This is achieved by union that contains the desired header structure and an instance of the most restrictive alignment type, which we have arbitrarily make a long:

In malloc(), the requested size in characters is rounded up to the proper number of header-sized units; the block that will be allocated contains one more unit, for the header itself, and this is the value recorded in the "size" field of the header. the pointer returned by malloc points at the free space, not at the header itself. The user can do anything with the space requested, but if anything is written outside of the allocated space the list is likely to be scrambled. 

The variable 'base' is used to get started. If freep is NULL, as it is at the first call of malloc, then a degenerated free list is created; it contains one block of size zero, and points to itself. In any case the free list is then searched. The search for a free block of adequate size begins at the point (freep) where the last block was found: this strategy helps keep the list homogeneous. If a too-big block is found, the tail end is returned to the user; in this way the header of the original needs only to have it's size adjusted in all cases, the pointer returned to the user points to the free space within the block, which begins one unit beyond the header. 

The function morecore() obtains storage from the operating system. 

The UNIX system call sbrk(n) returns a pointer to 'n' more bytes of storage.sbrk() returns -1 if there was no space, even though NULL could have been a better design. The -1 must be cast to( char *) so it can be compared with the return value. Cast makes the function relatively immune to the details of pointer representation on different machines. The assumptioins, however, that the pointer to different blocks return by sbrk() can be mainingfully compared.

The free() scans the free list, starting at freep, looking for the place to insert the fee block. This is either between two exiting blocks or at the end of the list in any case, if the block being freed is adjacent to either neighbor, the adjacent blocks are combined. The only troubles are keeping the pointers pointing to the right things and the size correct. 
 
